import { gunzip, ZlibOptions } from 'zlib';
import Signals = NodeJS.Signals;

export const getSumOfArraysLength = (twoDArray: Buffer[]) => twoDArray.reduce((memo, item) => (
    memo + item.length
), 0);

export function bufferFrom(items: Buffer[]): Buffer {
    const itemsLength = getSumOfArraysLength(items);
    let offset = 0;
    let end = 0;
    const finalBuffer = Buffer.alloc(itemsLength);

    items.forEach((item) => {
        finalBuffer.fill(item, offset, end += item.length);
        offset += item.length;
    });

    return finalBuffer;
}

export const isDebugMode = (): boolean => process.env.DEBBUG_CONNECTOR === true.toString();

export const toggleDebugMode = (toggle?: 'true' | 'false'): void => {
    process.env.DEBBUG_CONNECTOR = toggle;
};

export function onProcessExit(fn: (...args: any[]) => void) {
    ['exit', 'SIGINT', 'SIGUSR1', 'SIGUSR2', 'uncaughtException', 'SIGTERM'].forEach((eventType: Signals) => {
        process.on(eventType, fn);
    });
}

export function wrapErrorCallback(resolve: () => void, reject: () => void): (err?: Error) => void {
    return (err?: Error) => {
        if (err) {
            reject();
        }
        resolve();
    }
}


function gunzipAsPromise(buffer: Buffer, options: ZlibOptions = {}): Promise<Buffer> {
    return new Promise((resolve, reject) => gunzip(buffer, options, (err: Error, unzipped: Buffer) => {
        if (err) {
            return reject(err);
        }

        return resolve(unzipped);
    }));
}

export type SerialGunzip = (buffer: Buffer, options?: ZlibOptions) => Promise<Buffer>;

export function serialGunzipGenerator(): SerialGunzip {
    let lastPromise: Promise<Buffer>;

    return (buffer: Buffer, options?: ZlibOptions) => {
        // Chain to the last promise, this will guarantee that the promises will be executed in series
        lastPromise = lastPromise
            ? lastPromise.then(() => gunzipAsPromise(buffer, options))
            : gunzipAsPromise(buffer, options);

        return lastPromise;
    };
}

export enum ApiErrorCodes {
    InvalidRequest = '100',
    IOCommunication = '200',
    TooManyActiveSubscriptions = '300',
    SubscribeTooOften = '301',
    GetNextInitialDataTooOften = '304',
    GetNextUpdateDataTooOften = '305',
    UpdateDataResumeTooOften = '400',
    InternalServer = '1000',
}
