import { Socket } from 'net';
import { ConnectOptions, TCPConnectorClass, TCPConnectorState } from './tcp-connector.types';
import log from '../../core/log';
import { tcpEmitter } from '../tcp-emitter/tcp-emitter';
import sportsEngineParser from '../sports-engine-parser/sports-engine-parser';
import {
    getPingResponse,
    getSubscriptionMessage,
    getUnsubscribeRequest,
    getUpdateDataResumeRequest,
} from '../tcp-messages';
import { CommonEvents, TCPEvents } from '../../constants/eventNames';
import { SOCKET_KEEP_ALIVE, SOCKET_TIMEOUT, TCP_RECONNECT_INTERVAL } from '../../constants/defaults';
import { SubscribeResponse } from '../../core/messages.types';
import { wrapErrorCallback } from '../../utils';

export default class TCPConnector implements TCPConnectorClass {
    client: Socket | null;

    host: string;

    port: string;

    subscriptionSpecificationName: string;

    subscriptionId: string;

    subscriptionChecksum: string;

    state: TCPConnectorState = {
        connected: false,
        connecting: false,
    };

    reconnectAttempt: number = 0;

    getLastAppliedEntityChangeBatchUuid: () => string;

    constructor(host: string, port: string, subscriptionSpecificationName: string, getLastAppliedEntityChangeBatchUuid: () => string) {
        this.host = host;
        this.port = port;
        this.subscriptionSpecificationName = subscriptionSpecificationName;
        this.getLastAppliedEntityChangeBatchUuid = getLastAppliedEntityChangeBatchUuid;
    }

    async connect(
        sendSubscriptionProbe = true,
        options = {
            keepAlive: SOCKET_KEEP_ALIVE,
            timeout: SOCKET_TIMEOUT,
        },
    ): Promise<void> {
        const { state: { connected, connecting } } = this;

        if (connected || connecting) {
            return;
        }

        this.client = new Socket();

        await this.connectAndBindSocketEvents(options);

        if (sendSubscriptionProbe) {
            const subscriptionProbe = await getSubscriptionMessage(this.subscriptionSpecificationName);
            try {
                await this.writeToSocket(subscriptionProbe, `Subscription probe sent`);
            } catch (e) {
                tcpEmitter.emit(CommonEvents.runtimeError, e);
            }
        }

        tcpEmitter.on(TCPEvents.subscribe, (subscribeData: SubscribeResponse) => {
            const { SubscribeResponse: { subscriptionChecksum, subscriptionId } } = subscribeData;
            this.subscriptionId = subscriptionId;
            this.subscriptionChecksum = subscriptionChecksum;
        });

        tcpEmitter.on(TCPEvents.ping, async (pingId: string) => {
            const pingProbe = await getPingResponse(pingId);
            try {
                await this.writeToSocket(pingProbe, `Ping probe sent: ${pingId}`);
            } catch (e) {
                tcpEmitter.emit(CommonEvents.runtimeError, e);
            }
        });

        tcpEmitter.on(TCPEvents.tcpError, (errorCode: string) => {
            if (errorCode === '400' || errorCode === '1000') {
                this.disconnect();
                this.connect();
            }
        });
    }

    async reconnect(): Promise<void> {
        const lastBatchUuid = this.getLastAppliedEntityChangeBatchUuid();

        this.reconnectAttempt += 1;
        log(`Reconnect attempt ${this.reconnectAttempt}`);

        try {
            await this.disconnect();
            await this.connect(false);
            const reconnectProbe = await getUpdateDataResumeRequest(this.subscriptionId, this.subscriptionSpecificationName, this.subscriptionChecksum, lastBatchUuid);
            await this.writeToSocket(reconnectProbe);
        } catch (e) {
            tcpEmitter.emit(CommonEvents.runtimeError, e);
        }
    }

    async disconnect(): Promise<void> {
        this.state.connecting = false;
        this.state.connected = false;

        if (this.client && !this.client.destroyed) {
            const unsubscribeRequest = await getUnsubscribeRequest(this.subscriptionId, this.subscriptionSpecificationName);
            await this.writeToSocket(unsubscribeRequest, 'Unsubscribe probe sent');
            this.client.destroy();
            this.client.removeAllListeners();
        }
        this.client = null;
    }

    writeToSocket(message: Buffer, logMessage?: string): Promise<void> {
        return new Promise((resolve, reject) => {
            const gzippedMsgLength = message.length.toString();
            const zeroByte = Buffer.alloc(1);

            if (!this.client) {
                return;
            }

            this.client.write(gzippedMsgLength, wrapErrorCallback(resolve, reject));
            this.client.write(zeroByte, wrapErrorCallback(resolve, reject));
            this.client.write(message, 'utf8', wrapErrorCallback(resolve, reject));

            log(logMessage);
        });
    }

    connectAndBindSocketEvents({ keepAlive, timeout }: ConnectOptions): Promise<void> {
        const { client, host, port } = this;

        return new Promise((resolve, reject) => {
            if (!client) {
                reject();
                return;
            }

            client.on('connect', (): void => {
                this.state.connecting = false;
                this.reconnectAttempt = 0;
                resolve();
            });

            client.on('ready', (): void => {
                this.state.connected = true;
            });

            client.on('data', (data): void => {
                sportsEngineParser.parse(data);
            });

            client.on('end', (): void => {
                log('End');
            });

            client.on('error', async (e) => {
                setTimeout(() => {
                    this.reconnect();
                }, TCP_RECONNECT_INTERVAL);

                reject(e);
            });

            client.on('timeout', async () => {
                try {
                    await this.reconnect();
                } catch (e) {
                    tcpEmitter.emit(CommonEvents.runtimeError, e);
                }
            });

            this.state.connecting = true;

            client
                .setTimeout(timeout)
                .setKeepAlive(true, keepAlive)
                .connect({
                    port: +port,
                    host,
                });
        });
    }
}
