import HTTPConnector from './http/http-connector';
import { MAX_HTTP_UPDATE_REQUEST_INTERVAL, MIN_HTTP_UPDATE_REQUEST_INTERVAL } from './constants/defaults';
import {
    httpEmitter,
    initHandlers as httpEmitterInitHandlers,
    removeHandlers as httpEmitterRemoveHandlers,
} from './http/http-emitter';
import { CommonEvents, HTTPEvents } from './constants/eventNames';
import { InitialData, UpdateData } from './core/messages.types';
import log from './core/log';

export default abstract class SEPCPullConnector {
    httpConnector: HTTPConnector | null;

    protected constructor(public host: string, public port: string) {
    }

    async start(subscriptionSpecificationName: string, interval: number = MIN_HTTP_UPDATE_REQUEST_INTERVAL): Promise<void> {
        if (interval < MIN_HTTP_UPDATE_REQUEST_INTERVAL) {
            throw Error(`Update interval must be a value between ${MIN_HTTP_UPDATE_REQUEST_INTERVAL}ms and ${MAX_HTTP_UPDATE_REQUEST_INTERVAL}ms`);
        }

        httpEmitterInitHandlers();

        this.httpConnector = new HTTPConnector(this.host, this.port);

        httpEmitter.on(HTTPEvents.notifyInitialDump, (initialData: InitialData): void => this.notifyInitialDump(initialData));

        httpEmitter.on(HTTPEvents.notifyEntityUpdates, (updateData: UpdateData[]): void => this.notifyEntityUpdates(updateData));

        try {
            await this.httpConnector.connect(subscriptionSpecificationName, interval);
        } catch (e) {
            log(e);
            httpEmitter.emit(CommonEvents.runtimeError, e);
            await this.stop();
        }
    }

    async stop(): Promise<void> {
        if (this.httpConnector) {
            await this.httpConnector.disconnect();
            this.httpConnector = null;
        }
        httpEmitterRemoveHandlers();
    }

    abstract notifyInitialDump(entities: InitialData): void;

    abstract notifyEntityUpdates(entities: UpdateData[]): void;
}
