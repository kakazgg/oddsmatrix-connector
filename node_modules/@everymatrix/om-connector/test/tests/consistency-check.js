const { SEPCPushConnector, SEPCPullConnector } = require('@everymatrix/om-connector');

const logTimestamp = (msg, stream) => {
    const dateTime = new Date(Date.now());
    console.log(`[ ${dateTime.toDateString()} - ${dateTime.toTimeString()} ] - [ ${stream} ] - ${msg}`);
};

function ConsistencyChecker(stream) {
    const entityEntries = {};

    /*
      For a given subscription, this class monitors that the entities published by Sports Engine are consistent:
      - SE cannot publish an Entity Create twice for the same entity. The following case is valid: Create Entity X, Delete Entity X, Create Entity X.
      - SE cannot publish an Entity Update without having sent an Entity Create before for the same entity.
      - All published entities must have valid 'foreign keys'.
      - SE cannot publish an Entity Delete without having sent an Entity Create before for the same entity.
    */

    return {
        parseInitialData: (initialData) => {
            initialData.entities.forEach((entity) => {
                const { entityClass, id } = entity;
                if (!entityEntries[entityClass]) {
                    entityEntries[entityClass] = {};
                }
                entityEntries[entityClass][id] = true;
            });
            if (initialData.dumpComplete) {
                logTimestamp('Initial data dump completed.', stream);
            }
        },
        parseUpdateData: (updateData) => {
            const updates = Array.isArray(updateData) ? updateData : [updateData];
            updates.forEach(
                (update) => update.changes.forEach((entity) => {
                    const { entityClass, id, type } = entity;
                    if (!entityEntries[entityClass]) {
                        logTimestamp('SE cannot publish an "Entity Update" for an unknown entityClass.', stream);
                    }

                    if (type === 'create') {
                        if (entityEntries[entityClass][id] === true) {
                            logTimestamp('SE cannot publish an "Entity Create" twice for the same entity.', stream);
                        } else {
                            entityEntries[entityClass][id] = true;
                        }
                    }

                    if (type === 'update') {
                        if (!entityEntries[entityClass][id]) {
                            logTimestamp('SE cannot publish an "Entity Update" without having sent an "Entity Create" before for the same entity.', stream);
                        }
                    }

                    if (type === 'delete') {
                        if (!entityEntries[entityClass][id]) {
                            logTimestamp('SE cannot publish an "Entity Delete" without having sent an "Entity Create" before for the same entity.', stream);
                        } else {
                            entityEntries[entityClass][id] = false;
                        }
                    }
                }),
            );
        },
    };
}

class PushConsistencyChecker extends SEPCPushConnector {
    consistencyChecker = new ConsistencyChecker('TCP');

    lastChangeBatchUuid;

    notifyInitialDump(initialData) {
        this.consistencyChecker.parseInitialData(initialData);
    }

    notifyEntityUpdates(updateData) {
        this.lastChangeBatchUuid = updateData.batchUuid;
        this.consistencyChecker.parseUpdateData(updateData);
    }

    getLastAppliedEntityChangeBatchUuid() {
        return this.lastChangeBatchUuid;
    }
}

//
//

class PullConsistencyChecker extends SEPCPullConnector {
    consistencyChecker = new ConsistencyChecker('HTTP');

    notifyInitialDump(initialData) {
        this.consistencyChecker.parseInitialData(initialData);
    }

    notifyEntityUpdates(updateData) {
        this.consistencyChecker.parseUpdateData(updateData);
    }
}

module.exports = {
    PullConsistencyChecker,
    PushConsistencyChecker,
};
